/**
 * 题目：通配符匹配
 * 
 * 给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 '?' 和 '*' 的通配符匹配。
 * 
 *  '?' 可以匹配任何单个字符。
 *  '*' 可以匹配任意字符串（包括空字符串）。
 * 
 * 两个字符串完全匹配才算匹配成功。
 * 说明:
 * 
 *  s 可能为空，且只包含从 a-z 的小写字母。
 *  p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。
 * 
 * 示例 1:
 * 
 *  输入:
    s = "aa"
    p = "a"
    输出: false
    解释: "a" 无法匹配 "aa" 整个字符串。
 *
 * 示例 2:
 * 
 *  输入:
    s = "aa"
    p = "*"
    输出: true
    解释: '*' 可以匹配任意字符串。
 *
 * 示例 3:
 * 
 *  输入:
    s = "cb"
    p = "?a"
    输出: false
    解释: '?' 可以匹配 'c', 但第二个 'a' 无法匹配 'b'。
 *
 * 示例 4:
 * 
 *  输入:
    s = "adceb"
    p = "*a*b"
    输出: true
    解释: 第一个 '*' 可以匹配空字符串, 第二个 '*' 可以匹配字符串 "dce".
 *
 * 示例 5:
 * 
 *  输入:
    s = "acdcb"
    p = "a*c?b"
    输入: false
 *
 */

/**
 * @param {string} s
 * @param {string} p
 * @return {boolean}
 */
var isMatch = function (s, p) {
    var i = j = 0;
    var startI = startJ = -1;
    var sl = s.length, pl = p.length;
    while (i < sl) {
        if (j < pl && (p[j] == s[i] || p[j] == "?")) {
            i++ , j++;
        }
        else if (j < pl && p[j] == "*") {
            startI = i;
            startJ = j++;
        }
        else if (startI >= 0) {
            i = ++startI;
            j = startJ + 1;
        }
        else return false;
    }
    while (j < pl && p[j] == "*") j++;
    return j == pl;
};

/**
 * 思路：
 * 本题采用回溯的方法在LeetCode中提交会提示“超出时间限制”。
 * 因此本题采用双指针：
 *
 * i和j分别代表在当前s和p比较的字符的位置
 *
 * startI和startJ则表示匹配匹配不成功时，i和j应该重新匹配回到的位置
 *
 * 当i<s.length时，依次匹配s和p中的每一个字符
 * 1.如果j的索引没有超出p的超度-1，那么有三种情况：
 * 1.1.p[j] == s[i]：那么i和j的索引都后移 i++ , j++;
 * 1.2.p[j] == "?"：那么无论s[i]为什么字符，依然匹配成功，i和j的索引都后移 i++ , j++;
 * 1.3.p[j] == "*"，这时记录匹配s的字符的索引startI = i;同时记录p中连续（包含一个）出现“*”中第一个“*”的位置startJ
 * 2.一旦出现了p[j]!="*",并且同时p[j]!=s[i],那么说明之前*匹配的字符数不够，那么将*多匹配一个字符。
 *   2.1因为之前记录了s第一次匹配"*"时的字符的索引startI，因此多匹配一个字符，
 *      这时的i从++startI开始（回溯匹配时，++startI的原因“*”匹配的字符数只能增长不能减少）
 *   2.2因为之前记录了第一个“*”开始的位置startJ，因此此时从新回到p的这个“*”的位置开始匹配，将j重新职位startJ+1,
 *      （startJ + 1的原因是不能破坏最开始的位置（由于startJ从-1开始，始终比j的位置少1，所以要加上1），
 *      因为*匹配的字符可能依然不够，还会回溯匹配，所以不能用++startJ）。
 * 3.在与s匹配完以后，如果p还有未参与匹配的字符，while循环用于去掉多余的“*”。
 * 4.如果删除了多余的“*”，依然还有非“*”字符，则匹配不成功，反之成功。
 *
 */