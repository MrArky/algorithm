/**
 * 题目：K 个一组翻转链表
 * 
 * 给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。
 * k 是一个正整数，它的值小于或等于链表的长度。
 * 如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。
 * 
 * 示例 :
 * 
 *  给定这个链表：1->2->3->4->5
 *  当 k = 2 时，应当返回: 2->1->4->3->5
 *  当 k = 3 时，应当返回: 3->2->1->4->5
 * 
 * 说明：
 * 
 *  你的算法只能使用常数的额外空间。
 *  你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。
 */

/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} k
 * @return {ListNode}
 */
var reverseKGroup = function (head, k) {
    let left = boot = { val: 0, next: head };
    let i = k;
    while (head != null && head.next != null && i > 1) {
        i--;
        let next = head.next;
        head.next = head.next.next;
        left.next = {             //  let leftNext=left.next;
            val: next.val,        //  left.next=new ListNode(next.val);
            next: left.next       //  left.next.next=leftNext;
        };
        if (i == 1) {
            left = head, head = head.next, i = k;
        }
    }
    if (i > 1 && i < k) {
        // left.next = reverseKGroup(left.next, i);  //为什么这么执行不行，是引用问题吗？
        var temp = left, head = left.next;
        while (head != null && head.next != null) {
            i--;
            let next = head.next;
            head.next = head.next.next;
            temp.next = {             //  let leftNext=left.next;
                val: next.val,        //  left.next=new ListNode(next.val);
                next: temp.next       //  left.next.next=leftNext;
            };
        }
    }
    return boot.next;
};

/**
 * 思路：
 *
 * 1.可以想象一下，如何做到翻转整个链表，即：
 *
 *  1->2->3->4->5->6->7->8  ==>  8->7->6->5->4->3->2->1
 *
 * 第一次执行：
 *
 *  1-> | 2->3->4->5->6->7->8 ==> 需要1->3、2->1 ==>2->1->3->4->5->6->7->8
 *
 * 第二次执行：
 *
 *  2->1-> | 3->4->5->6->7->8 ==> 需要1->4、3->2 ==>2->1->3->4->5->6->7->8
 *
 * 得出一个结论：
 * 1.每次遍历将跟节点1，指向下一个节点的下一个节点
 * 2.下一个指向链表当前的跟节点
 *
 * 问题：每次当前跟节点，即1->中的1、2->1->中的2是动态的，不易捕获该对象
 *
 * 为了更好的描述，将原始链表加一个跟节点，即：
 *
 *  0->1->2->3->4->5->6->7->8 ==>  0->8->7->6->5->4->3->2->1
 *
 * 第一次执行：
 *
 *  0->1-> | 2->3->4->5->6->7->8 ==> 需要1->3、0->2 ==>2->1->3->4->5->6->7->8
 *
 * 第二次
 *
 *  0->2->1-> | 3->4->5->6->7->8 ==> 需要1->4、0->3 ==>2->1->3->4->5->6->7->8
 *
 * 由此可见，每次的工作如下：
 * 1.每次遍历将跟节点1，指向下一个节点的下一个节点
 * 2.将0这个节点指向下一个节点，下一个节点指向之前0指向的节点
 *
 * 但是，题目要求总有个翻转的要求k(假设为3)，即每k个元素翻转一次，即需要得到以下结果：
 *
 *  0->3->2->1->6->5->4-8->7
 *
 * 所以在遍历链表时，我们需要注意，每k个节点完成翻转时，如前k(3)个完成翻转时如下：
 *
 *  0->3->2->1->4->5->6-7->8
 *
 * 需要重新指定链表的开始节点（原来为1）为4，原始跟节点（原来为0）为1，一次类推，最后得到一下结果：
 *
 *  0->3->2->1->6->5->4-8->7
 *
 * 问题：
 *    8->7的长度为2，按照题目的要求不能翻转，因此最后的翻转需要验证，如果长度不为k(3)，即不翻转。
 *    因为本题未知链表长度，因此无法的得知是否到了最后一次翻转，因此只有翻转完成以后，如果最后一次反转
 * 的元素总长度小于k，只有再次翻转回来。
 *
 * 时间复杂度为：O(n+n%k)
 *
 *
 */